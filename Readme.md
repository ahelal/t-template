## t-template

A string interpolator and template processor cli tool.

## Why

t-template was conceived to solve transforming strings in a flexible way. In our CI system we have JSON/YAML being generated by various system and needs to be consumed in different styles/format.

so simply t-template is a contained binary that consumes variables from stdin/file(s) as JSON and/or yaml and output templated file.

example input yaml file
```yaml
- Username: "user1"
  Name: "User One"
- Username: "user2"
  Name: "User Two"
- Username: "user3"
  Name: "User Three"
```

example template
```
{{ range .}}{{ range .}}
Username: {{.Username}} Name: {{.Name}}{{ end }}
{{ end }}
```

Running the example
```bash
cd test/examples/simple
t-template ./simple.ctmp --yaml users.yml
```

Output
```
Username: user1 Name: User One
Username: user2 Name: User Two
Username: user3 Name: User Three
```
## Inputs

t-template support various input method

### Stdin input

You can pass JSON or yaml via stdin.

**yaml**
```bash
cd test/examples/simple
cat users.yml | ./simple.ctmp --stdin-yaml
```

**JSON**
```bash
cd test/examples/simple
cat users.json | ./simple.ctmp --stdin-json
```

### Files input

You can pass both JSON and yaml files as an arguments in a mixed mode ```-j FILE --json=FILE```  ```-y FILE --yaml=FILE```. You can repeat them for each file.

```bash
cd test/examples/usernames
./userReport.tmp -j ht.json -j pk.json -j ra.json -y cj.yml -y jp.yml -y yo.yml
```

### Note

You can also pass stdin and files together

```bash
cd test/examples/simple
cat users.json | ./simple.ctmp --stdin-json -j users.json
```

## Output

By default the template is printed to **stdout** and *error*, *warning* and *info* to **stderr**.

So you can use normal unix pipe or redirects. i.e. ```./simple.ctmp -y input.yml | other_program```

You can also use ```-o FILE --output=FILE``` for outputting to a file.

## Template

t-template supports standard [go template](https://golang.org/pkg/text/template) syntax and function
It also has loads of other functions ">100" for full list please check [sprig](https://github.com/Masterminds/sprig)

### Your . is a slice

t-template passes variables within a slice. so your root is always a slice. Most probably your template will always start with

```
{{ range . }}
SOME SORT OF TEMPLATE
{{ end }}
```

### White spaces

White spaces are always tricky this might help http://mozilla.github.io/nunjucks/templating.html#whitespace-control

## Running

You can run t-template by executing the binary and giving it arguments.

```bash
cd test/examples/simple
t-template ./simple.ctmp --json users.json
```
### hashbang

You can make your template executable and add a hashbang in the first line ```#!/usr/bin/env t-template```

```bash
cd test/examples/simple
./simple.ctmp --json users.json
```
by default t-template checks for **#!** in the beginning of file and removes the first line. If you still want the hashbang to be templated.
you can pass ```-i or --ignore-hashbang```

If your running MAC you can pass arguments in the hashbang, but this will fail for linux and it is _not POSIX_ ```#!/usr/bin/env t-template --json users.json```
And if you decided to do that you have a limit of 127 chars for the entire hashbang line.

## Delimiters

By default t-template support the standard go **{{** **}}** delimiters you can change this by passing ```--left-delimiter="[[" --right-delimiter="]]"```
*Note: depending on your delimiters you might need to escape it with quotes to avoid your shell from interpreting it*

```bash
cd test/examples/delim
t-template delim.ctmp -j test1.json -j test2.json -j test3.json -y test4.yml -l "<%" -r "%>"
```

## Arguments

To list supported arguments run ```t-template --help```

## Examples

Check the [examples dir](https://github.com/ahelal/t-template/tree/master/examples)

## TODO

* Tests
* Support directory load
* Support HCL syntax https://www.terraform.io/docs/configuration/syntax.html
* Support auto serialization detection ( or at least just try JSON if it fails try yaml if it fails give up)

## License
MIT
